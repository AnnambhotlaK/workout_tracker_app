import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/workout.dart'; // Your Workout model
import '../models/session.dart';

class FirestoreService {
  final FirebaseFirestore _db = FirebaseFirestore.instance;

  // --- Workout Methods ---

  // CREATE: Add a new workout for a given user
  Future<DocumentReference> addWorkout(String userId, Workout workout) {
    // Workout ID will be auto-generated by Firestore unless you set it
    return _db
        .collection('users')
        .doc(userId)
        .collection('workouts')
        .add(workout.toJson()); // toJson includes serverTimestamp for createdAt
  }

  // READ: Get stream of workouts for a given user
  Stream<List<Workout>> getWorkouts(String userId) {
    return _db
        .collection('users')
        .doc(userId)
        .collection('workouts')
        // .orderBy('createdAt', descending: true) // Optional: order by creation time
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => Workout.fromSnapshot(doc)).toList());
  }

  // UPDATE: Modify an existing workout
  Future<void> updateWorkout(String userId, Workout workout) {
    var updatedData = workout.toJson();
    // Add/update an 'updatedAt' timestamp
    updatedData['updatedAt'] = FieldValue.serverTimestamp();
    return _db
        .collection('users')
        .doc(userId)
        .collection('workouts')
        .doc(workout.id)
        .update(updatedData);
  }

  // DELETE: Remove a given workout
  Future<void> deleteWorkout(String userId, String workoutId) {
    return _db
        .collection('users')
        .doc(userId)
        .collection('workouts')
        .doc(workoutId)
        .delete();
  }

  // -- Session Methods --
  // CREATE: Add a new session for a given user
  Future<DocumentReference> addSession(String userId, Session session) {
    // Workout ID will be auto-generated by Firestore unless you set it
    return _db
        .collection('users')
        .doc(userId)
        .collection('sessions')
        .add(session.toJson()); // toJson includes serverTimestamp for createdAt
  }

  // READ: Get stream of sessions for a given user
  Stream<List<Session>> getSessions(String userId,
      {DateTime? startDate, DateTime? endDate}) {
    Query query = _db
        .collection('users')
        .doc(userId)
        .collection('sessions')
        .orderBy('dateCompleted', descending: true);
    if (startDate != null) {
      query = query.where('dateCompleted',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));
    }
    if (endDate != null) {
      DateTime eod =
          DateTime(endDate.year, endDate.month, endDate.day, 23, 59, 59);
      query = query.where('dateCompleted',
          isLessThanOrEqualTo: Timestamp.fromDate(eod));
    }

    return query.snapshots().map((snapshot) =>
        snapshot.docs.map((doc) => Session.fromSnapshot(doc)).toList());
  }

  // UPDATE: Modify an existing session
  Future<void> updateSession(String userId, Session session) {
    var updatedData = session.toJson();
    // Add/update an 'updatedAt' timestamp
    //updatedData['updatedAt'] = FieldValue.serverTimestamp();
    return _db
        .collection('users')
        .doc(userId)
        .collection('sessions')
        .doc(session.id)
        .update(updatedData);
  }

  // DELETE: Remove a given workout
  Future<void> deleteSession(String userId, String sessionId) {
    return _db
        .collection('users')
        .doc(userId)
        .collection('sessions')
        .doc(sessionId)
        .delete();
  }
}
